{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[353],{763:function(t,a,e){\"use strict\";e.r(a);var r=e(44),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[e(\"p\",[t._v(\"[TOC]\")]),t._v(\" \"),e(\"h1\",{attrs:{id:\"第二节-请求处理过程\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#第二节-请求处理过程\"}},[t._v(\"#\")]),t._v(\" 第二节 请求处理过程\")]),t._v(\" \"),e(\"h2\",{attrs:{id:\"_1、总体阶段\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、总体阶段\"}},[t._v(\"#\")]),t._v(\" 1、总体阶段\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_1流程描述\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1流程描述\"}},[t._v(\"#\")]),t._v(\" ①流程描述\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"目标 handler 方法执行\"),e(\"span\",{staticStyle:{color:\"blue\",\"font-weight\":\"bold\"}},[t._v(\"前\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"建立调用链，确定整个执行流程\")]),t._v(\" \"),e(\"li\",[t._v(\"拦截器的 preHandle() 方法\")]),t._v(\" \"),e(\"li\",[t._v(\"注入请求参数\")]),t._v(\" \"),e(\"li\",[t._v(\"准备目标 handler 方法所需所有参数\")])])]),t._v(\" \"),e(\"li\",[e(\"span\",{staticStyle:{color:\"blue\",\"font-weight\":\"bold\"}},[t._v(\"调用\")]),t._v(\"目标 handler 方法\")]),t._v(\" \"),e(\"li\",[t._v(\"目标 handler 方法执行\"),e(\"span\",{staticStyle:{color:\"blue\",\"font-weight\":\"bold\"}},[t._v(\"后\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"拦截器的 postHandle() 方法\")]),t._v(\" \"),e(\"li\",[t._v(\"渲染视图\")]),t._v(\" \"),e(\"li\",[t._v(\"拦截器的 afterCompletion() 方法\")])])])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_2核心代码\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2核心代码\"}},[t._v(\"#\")]),t._v(\" ②核心代码\")]),t._v(\" \"),e(\"p\",[t._v(\"整个请求处理过程都是 doDispatch() 方法在宏观上协调和调度，把握了这个方法就理解了 SpringMVC 总体上是如何处理请求的。\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.\"),e(\"span\",{staticStyle:{color:\"blue\",\"font-weight\":\"bold\"}},[t._v(\"DispatcherServlet\")])]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：doDispatch()\")]),t._v(\" \"),e(\"p\",[t._v(\"核心方法中的核心代码：\")]),t._v(\" \"),e(\"div\",{staticClass:\"language-java extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[e(\"code\",[e(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[t._v(\"// Actually invoke the handler.\")]),t._v(\"\\nmv \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" ha\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),e(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"handle\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"processedRequest\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" response\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" mappedHandler\"),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\".\")]),e(\"span\",{pre:!0,attrs:{class:\"token function\"}},[t._v(\"getHandler\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),e(\"h2\",{attrs:{id:\"_2、调用前阶段\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、调用前阶段\"}},[t._v(\"#\")]),t._v(\" 2、调用前阶段\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_1建立调用链\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1建立调用链\"}},[t._v(\"#\")]),t._v(\" ①建立调用链\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_1-相关组件\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-相关组件\"}},[t._v(\"#\")]),t._v(\" [1]相关组件\")]),t._v(\" \"),e(\"p\",[t._v(\"全类名：org.springframework.web.servlet.HandlerExecutionChain\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img003.png\",alt:\"images\"}})]),t._v(\" \"),e(\"p\",[t._v(\"拦截器索引默认是 -1，说明开始的时候，它指向第一个拦截器前面的位置。每执行一个拦截器，就把索引向前移动一个位置。所以这个索引每次都是指向当前拦截器。所以它相当于拦截器的\"),e(\"span\",{staticStyle:{color:\"blue\",\"font-weight\":\"bold\"}},[t._v(\"指针\")]),t._v(\"。\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_2-对应操作\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-对应操作\"}},[t._v(\"#\")]),t._v(\" [2]对应操作\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.handler.AbstractHandlerMapping\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img004.png\",alt:\"images\"}})]),t._v(\" \"),e(\"p\",[t._v(\"结论：调用链是由拦截器和目标 handler 对象组成的。\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_2调用拦截器-prehandle\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2调用拦截器-prehandle\"}},[t._v(\"#\")]),t._v(\" ②调用拦截器 preHandle()\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.DispatcherServlet\")]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：doDispatch()\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img007.png\",alt:\"images\"}})]),t._v(\" \"),e(\"p\",[t._v(\"具体调用细节：正序调用\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.HandlerExecutionChain\")]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：applyPreHandle\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img008.png\",alt:\"images\"}})]),t._v(\" \"),e(\"p\",[t._v(\"从这部分代码我们也能看到，为什么拦截器中的 preHandle() 方法通过返回布尔值能够控制是否放行。\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"每一个拦截器的 preHandle() 方法都返回 true：applyPreHandle() 方法返回 true，被取反就不执行 if 分支，继续执行后续操作，这就是放行。\")]),t._v(\" \"),e(\"li\",[t._v(\"任何一个拦截器的 preHandle() 方法返回 false：applyPreHandle() 方法返回 false，被取反执行 if 分支，return，导致 doDispatch() 方法结束，不执行后续操作，就是不放行。\")])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_3注入请求参数\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3注入请求参数\"}},[t._v(\"#\")]),t._v(\" ③注入请求参数\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_1-相关组件-2\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-相关组件-2\"}},[t._v(\"#\")]),t._v(\" [1]相关组件\")]),t._v(\" \"),e(\"p\",[t._v(\"接口：org.springframework.web.servlet.HandlerAdapter\")]),t._v(\" \"),e(\"p\",[t._v(\"作用：字面含义是适配器的意思，具体功能有三个\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"将请求参数绑定到实体类对象中\")]),t._v(\" \"),e(\"li\",[t._v(\"给目标 handler 方法准备所需的其他参数，例如：\\n\"),e(\"ul\",[e(\"li\",[t._v(\"Model、ModelMap、Map……\")]),t._v(\" \"),e(\"li\",[t._v(\"原生 Servlet API：request、response、session……\")]),t._v(\" \"),e(\"li\",[t._v(\"BindingResult\")]),t._v(\" \"),e(\"li\",[t._v(\"@RequestParam 注解标记的零散请求参数\")]),t._v(\" \"),e(\"li\",[t._v(\"@PathVariable 注解标记的路径变量\")])])]),t._v(\" \"),e(\"li\",[t._v(\"调用目标 handler 方法\")])]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_2-创建并获取这个组件\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-创建并获取这个组件\"}},[t._v(\"#\")]),t._v(\" [2]创建并获取这个组件\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.DispatcherServlet\")]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：doDispatch()\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img009.png\",alt:\"images\"}})]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_3-具体操作-调用目标-handler-方法\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-具体操作-调用目标-handler-方法\"}},[t._v(\"#\")]),t._v(\" [3]具体操作：调用目标 handler 方法\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.DispatcherServlet\")]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：doDispatch()\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img010.png\",alt:\"images\"}})]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_4-具体操作-注入请求参数\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-具体操作-注入请求参数\"}},[t._v(\"#\")]),t._v(\" [4]具体操作：注入请求参数\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img011.png\",alt:\"images\"}})]),t._v(\" \"),e(\"p\",[t._v(\"通过反射给对应属性注入请求参数应该是下面的过程：\")]),t._v(\" \"),e(\"ul\",[e(\"li\",[t._v(\"获取请求参数名称\")]),t._v(\" \"),e(\"li\",[t._v(\"将请求参数名称首字母设定为大写\")]),t._v(\" \"),e(\"li\",[t._v(\"在首字母大写后的名称前附加 set，得到目标方法名\")]),t._v(\" \"),e(\"li\",[t._v(\"通过反射调用 setXxx() 方法\")])]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_4准备其他参数\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4准备其他参数\"}},[t._v(\"#\")]),t._v(\" ④准备其他参数\")]),t._v(\" \"),e(\"p\",[t._v(\"以 Model 为例来进行说明。\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_1-背景\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-背景\"}},[t._v(\"#\")]),t._v(\" [1]背景\")]),t._v(\" \"),e(\"p\",[t._v(\"在 handler 方法中，如果需要 Model、ModelMap、Map 等对象用来存放模型数据，那么直接在 handler 方法中声明这些类型的形参即可。\")]),t._v(\" \"),e(\"p\",[t._v(\"而不管我们声明 Model、ModelMap、Map 三者中的任何一个，其实实际传入的对象都是 BindingAwareModelMap 类型的。\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_2-相关组件\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-相关组件\"}},[t._v(\"#\")]),t._v(\" [2]相关组件\")]),t._v(\" \"),e(\"p\",[t._v(\"组件类：org.springframework.web.method.support.ModelAndViewContainer\")]),t._v(\" \"),e(\"p\",[t._v(\"相关属性：defaultModel\")]),t._v(\" \"),e(\"div\",{staticClass:\"language-java extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[e(\"code\",[e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"private\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"final\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"ModelMap\")]),t._v(\" defaultModel \"),e(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"new\")]),t._v(\" \"),e(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"BindingAwareModelMap\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),e(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])])]),e(\"p\",[t._v(\"从这个属性的声明能够看出：defaultModel 直接就是用 BindingAwareModelMap 对象来初始化的。\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_3-相关操作\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-相关操作\"}},[t._v(\"#\")]),t._v(\" [3]相关操作\")]),t._v(\" \"),e(\"p\",[t._v(\"相关接口：org.springframework.web.servlet.HandlerAdapter\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\")]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：invokeHandlerMethod()\")]),t._v(\" \"),e(\"p\",[t._v(\"操作1：创建 ModelAndViewContainer 对象\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img012.png\",alt:\"images\"}})]),t._v(\" \"),e(\"p\",[t._v(\"操作2：把 ModelAndViewContainer 对象传给 invokeAndHandle() 方法\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img013.png\",alt:\"images\"}})]),t._v(\" \"),e(\"h2\",{attrs:{id:\"_3、调用后阶段\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3、调用后阶段\"}},[t._v(\"#\")]),t._v(\" 3、调用后阶段\")]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_1调用拦截器的-posthandle-方法\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1调用拦截器的-posthandle-方法\"}},[t._v(\"#\")]),t._v(\" ①调用拦截器的 postHandle() 方法\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.DispatcherServlet\")]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：doDispatch()\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img014.png\",alt:\"images\"}})]),t._v(\" \"),e(\"p\",[t._v(\"调用细节：从拦截器集合长度 - 1 开始循环，循环到 0 为止。所以是\"),e(\"span\",{staticStyle:{color:\"blue\",\"font-weight\":\"bold\"}},[t._v(\"倒序\")]),t._v(\"执行。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img015.png\",alt:\"images\"}})]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_2渲染视图\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2渲染视图\"}},[t._v(\"#\")]),t._v(\" ②渲染视图\")]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_1-所有后续操作的入口\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-所有后续操作的入口\"}},[t._v(\"#\")]),t._v(\" [1]所有后续操作的入口\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.DispatcherServlet\")]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：doDispatch()\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img016.png\",alt:\"images\"}})]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_2-后续细节1-处理异常\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-后续细节1-处理异常\"}},[t._v(\"#\")]),t._v(\" [2]后续细节1：处理异常\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.DispatcherServlet\")]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：processDispatchResult()\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img017.png\",alt:\"images\"}})]),t._v(\" \"),e(\"h4\",{attrs:{id:\"_3-后续细节2-渲染视图\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-后续细节2-渲染视图\"}},[t._v(\"#\")]),t._v(\" [3]后续细节2：渲染视图\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.DispatcherServlet\")]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：processDispatchResult()\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img018.png\",alt:\"images\"}})]),t._v(\" \"),e(\"p\",[t._v(\"补充细节：模型数据存入请求域的具体位置\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.thymeleaf.context.WebEngineContext.RequestAttributesVariablesMap\")]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：setVariable()\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img020.png\",alt:\"images\"}})]),t._v(\" \"),e(\"h3\",{attrs:{id:\"_3调用拦截器的-aftercompletion-方法\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3调用拦截器的-aftercompletion-方法\"}},[t._v(\"#\")]),t._v(\" ③调用拦截器的 afterCompletion() 方法\")]),t._v(\" \"),e(\"p\",[t._v(\"所在类：org.springframework.web.servlet.DispatcherServlet\")]),t._v(\" \"),e(\"p\",[t._v(\"所在方法：processDispatchResult()\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img019.png\",alt:\"images\"}})]),t._v(\" \"),e(\"p\",[t._v(\"调用细节：从拦截器索引开始循环，直到循环变量 i 被减到 0 为止。这样的效果是前面执行拦截器到哪里，就从哪里倒回去执行；前面没有执行的拦截器，现在也不执行。\")]),t._v(\" \"),e(\"p\",[e(\"img\",{attrs:{src:\"images/img021.png\",alt:\"images\"}})]),t._v(\" \"),e(\"h2\",{attrs:{id:\"_4、所有断点总结\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4、所有断点总结\"}},[t._v(\"#\")]),t._v(\" 4、所有断点总结\")]),t._v(\" \"),e(\"p\",[t._v(\"断点位置基准：SpringMVC 版本采用 5.3.1 且源码已经下载，包含注释。\")]),t._v(\" \"),e(\"table\",[e(\"thead\",[e(\"tr\",[e(\"th\",[t._v(\"所在类\")]),t._v(\" \"),e(\"th\",[t._v(\"所在方法\")]),t._v(\" \"),e(\"th\",[t._v(\"断点行数\")]),t._v(\" \"),e(\"th\",[t._v(\"作用\")])])]),t._v(\" \"),e(\"tbody\",[e(\"tr\",[e(\"td\",[t._v(\"DispatcherServlet\")]),t._v(\" \"),e(\"td\",[t._v(\"doDispatch()\")]),t._v(\" \"),e(\"td\",[t._v(\"1037\")]),t._v(\" \"),e(\"td\",[t._v(\"创建调用链对象\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"DispatcherServlet\")]),t._v(\" \"),e(\"td\",[t._v(\"doDispatch()\")]),t._v(\" \"),e(\"td\",[t._v(\"1044\")]),t._v(\" \"),e(\"td\",[t._v(\"创建 HandlerAdapter 对象\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"DispatcherServlet\")]),t._v(\" \"),e(\"td\",[t._v(\"doDispatch()\")]),t._v(\" \"),e(\"td\",[t._v(\"1056\")]),t._v(\" \"),e(\"td\",[t._v(\"调用拦截器 preHandle()方法\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"DispatcherServlet\")]),t._v(\" \"),e(\"td\",[t._v(\"doDispatch()\")]),t._v(\" \"),e(\"td\",[t._v(\"1061\")]),t._v(\" \"),e(\"td\",[t._v(\"执行目标 handler 方法\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"DispatcherServlet\")]),t._v(\" \"),e(\"td\",[t._v(\"doDispatch()\")]),t._v(\" \"),e(\"td\",[t._v(\"1068\")]),t._v(\" \"),e(\"td\",[t._v(\"调用拦截器 postHandle()方法\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"DispatcherServlet\")]),t._v(\" \"),e(\"td\",[t._v(\"doDispatch()\")]),t._v(\" \"),e(\"td\",[t._v(\"1078\")]),t._v(\" \"),e(\"td\",[t._v(\"执行所有后续操作\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"AbstractHandlerMapping\")]),t._v(\" \"),e(\"td\",[t._v(\"getHandlerExecutionChain()\")]),t._v(\" \"),e(\"td\",[t._v(\"592\")]),t._v(\" \"),e(\"td\",[t._v(\"创建调用链对象\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"AbstractHandlerMapping\")]),t._v(\" \"),e(\"td\",[t._v(\"getHandlerExecutionChain()\")]),t._v(\" \"),e(\"td\",[t._v(\"599\")]),t._v(\" \"),e(\"td\",[t._v(\"在调用链中添加拦截器\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"HandlerExecutionChain\")]),t._v(\" \"),e(\"td\",[t._v(\"applyPreHandle()\")]),t._v(\" \"),e(\"td\",[t._v(\"146\")]),t._v(\" \"),e(\"td\",[t._v(\"调用拦截器 preHandle()方法\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"HandlerExecutionChain\")]),t._v(\" \"),e(\"td\",[t._v(\"applyPostHandle()\")]),t._v(\" \"),e(\"td\",[t._v(\"163\")]),t._v(\" \"),e(\"td\",[t._v(\"调用拦截器 postHandle()方法\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"HandlerExecutionChain\")]),t._v(\" \"),e(\"td\",[t._v(\"triggerAfterCompletion\")]),t._v(\" \"),e(\"td\",[t._v(\"175\")]),t._v(\" \"),e(\"td\",[t._v(\"调用拦截器 afterCompletion()方法\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"DataBinder\")]),t._v(\" \"),e(\"td\",[t._v(\"doBind()\")]),t._v(\" \"),e(\"td\",[t._v(\"747\")]),t._v(\" \"),e(\"td\",[t._v(\"执行数据绑定\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"RequestMappingHandlerAdapter\")]),t._v(\" \"),e(\"td\",[t._v(\"invokeHandlerMethod()\")]),t._v(\" \"),e(\"td\",[t._v(\"868\")]),t._v(\" \"),e(\"td\",[t._v(\"创建 ModelAndViewContainer 对象\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"RequestMappingHandlerAdapter\")]),t._v(\" \"),e(\"td\",[t._v(\"invokeHandlerMethod()\")]),t._v(\" \"),e(\"td\",[t._v(\"893\")]),t._v(\" \"),e(\"td\",[t._v(\"将ModelAndViewContainer 对象传入调用目标 handler 的方法\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"DispatcherServlet\")]),t._v(\" \"),e(\"td\",[t._v(\"processDispatchResult()\")]),t._v(\" \"),e(\"td\",[t._v(\"1125\")]),t._v(\" \"),e(\"td\",[t._v(\"处理异常\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"DispatcherServlet\")]),t._v(\" \"),e(\"td\",[t._v(\"processDispatchResult()\")]),t._v(\" \"),e(\"td\",[t._v(\"1139\")]),t._v(\" \"),e(\"td\",[t._v(\"渲染视图\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"DispatcherServlet\")]),t._v(\" \"),e(\"td\",[t._v(\"processDispatchResult()\")]),t._v(\" \"),e(\"td\",[t._v(\"1157\")]),t._v(\" \"),e(\"td\",[t._v(\"调用拦截器 afterCompletion()方法\")])]),t._v(\" \"),e(\"tr\",[e(\"td\",[t._v(\"WebEngineContext的内部类：\"),e(\"br\"),t._v(\"RequestAttributesVariablesMap\")]),t._v(\" \"),e(\"td\",[t._v(\"setVariable()\")]),t._v(\" \"),e(\"td\",[t._v(\"783\")]),t._v(\" \"),e(\"td\",[t._v(\"将模型数据存入请求域\")])])])]),t._v(\" \"),e(\"p\",[e(\"RouterLink\",{attrs:{to:\"/pro005-SpringMVC/lecture/chapter05/verse01.html\"}},[t._v(\"上一节\")]),t._v(\" \"),e(\"RouterLink\",{attrs:{to:\"/pro005-SpringMVC/lecture/chapter05/index.html\"}},[t._v(\"回目录\")]),t._v(\" \"),e(\"RouterLink\",{attrs:{to:\"/pro005-SpringMVC/lecture/chapter05/verse03.html\"}},[t._v(\"下一节\")])],1)])}),[],!1,null,null,null);a.default=v.exports}}]);","extractedComments":[]}